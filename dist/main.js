/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/pitchfinder/lib/detectors/acf2plus.js":
/*!************************************************************!*\
  !*** ./node_modules/pitchfinder/lib/detectors/acf2plus.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar DEFAULT_PARAMS = {\n    sampleRate: 44100,\n};\nfunction ACF2PLUS(params) {\n    if (params === void 0) { params = DEFAULT_PARAMS; }\n    var config = __assign(__assign({}, DEFAULT_PARAMS), params);\n    var sampleRate = config.sampleRate;\n    // Implements the ACF2+ algorithm\n    return function ACF2PLUSDetector(float32AudioBuffer) {\n        var maxShift = float32AudioBuffer.length;\n        var rms = 0;\n        var i, j, u, tmp;\n        for (i = 0; i < maxShift; i++) {\n            tmp = float32AudioBuffer[i];\n            rms += tmp * tmp;\n        }\n        rms = Math.sqrt(rms / maxShift);\n        if (rms < 0.01)\n            // not enough signal\n            return -1;\n        /* Trimming cuts the edges of the signal so that it starts and ends near zero.\n         This is used to neutralize an inherent instability of the ACF version I use.*/\n        var aux1 = 0;\n        var aux2 = maxShift - 1;\n        var thres = 0.2;\n        for (i = 0; i < maxShift / 2; i++)\n            if (Math.abs(float32AudioBuffer[i]) < thres) {\n                aux1 = i;\n                break;\n            }\n        for (i = 1; i < maxShift / 2; i++)\n            if (Math.abs(float32AudioBuffer[maxShift - i]) < thres) {\n                aux2 = maxShift - i;\n                break;\n            }\n        var frames = float32AudioBuffer.slice(aux1, aux2);\n        var framesLength = frames.length;\n        var calcSub = new Array(framesLength).fill(0);\n        for (i = 0; i < framesLength; i++)\n            for (j = 0; j < framesLength - i; j++)\n                calcSub[i] = calcSub[i] + frames[j] * frames[j + i];\n        u = 0;\n        while (calcSub[u] > calcSub[u + 1])\n            u++;\n        var maxval = -1, maxpos = -1;\n        for (i = u; i < framesLength; i++) {\n            if (calcSub[i] > maxval) {\n                maxval = calcSub[i];\n                maxpos = i;\n            }\n        }\n        var T0 = maxpos;\n        /* Interpolation is parabolic interpolation. It helps with precision.\n         We suppose that a parabola pass through the three points that comprise the peak.\n         'a' and 'b' are the unknowns from the linear equation system\n         and b/(2a) is the \"error\" in the abscissa.\n         y1,y2,y3 are the ordinates.*/\n        var y1 = calcSub[T0 - 1], y2 = calcSub[T0], y3 = calcSub[T0 + 1];\n        var a = (y1 + y3 - 2 * y2) / 2;\n        var b = (y3 - y1) / 2;\n        if (a)\n            T0 = T0 - b / (2 * a);\n        return sampleRate / T0;\n    };\n}\nexports.ACF2PLUS = ACF2PLUS;\n\n\n//# sourceURL=webpack:///./node_modules/pitchfinder/lib/detectors/acf2plus.js?");

/***/ }),

/***/ "./node_modules/pitchfinder/lib/detectors/amdf.js":
/*!********************************************************!*\
  !*** ./node_modules/pitchfinder/lib/detectors/amdf.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar DEFAULT_AMDF_PARAMS = {\n    sampleRate: 44100,\n    minFrequency: 82,\n    maxFrequency: 1000,\n    ratio: 5,\n    sensitivity: 0.1,\n};\nfunction AMDF(params) {\n    if (params === void 0) { params = {}; }\n    var config = __assign(__assign({}, DEFAULT_AMDF_PARAMS), params);\n    var sampleRate = config.sampleRate;\n    var minFrequency = config.minFrequency;\n    var maxFrequency = config.maxFrequency;\n    var sensitivity = config.sensitivity;\n    var ratio = config.ratio;\n    var amd = [];\n    /* Round in such a way that both exact minPeriod as\n     exact maxPeriod lie inside the rounded span minPeriod-maxPeriod,\n     thus ensuring that minFrequency and maxFrequency can be found\n     even in edge cases */\n    var maxPeriod = Math.ceil(sampleRate / minFrequency);\n    var minPeriod = Math.floor(sampleRate / maxFrequency);\n    return function AMDFDetector(float32AudioBuffer) {\n        var maxShift = float32AudioBuffer.length;\n        var t = 0;\n        var minval = Infinity;\n        var maxval = -Infinity;\n        var frames1, frames2, calcSub, i, j, u, aux1, aux2;\n        // Find the average magnitude difference for each possible period offset.\n        for (i = 0; i < maxShift; i++) {\n            if (minPeriod <= i && i <= maxPeriod) {\n                for (aux1 = 0, aux2 = i, t = 0, frames1 = [], frames2 = []; aux1 < maxShift - i; t++, aux2++, aux1++) {\n                    frames1[t] = float32AudioBuffer[aux1];\n                    frames2[t] = float32AudioBuffer[aux2];\n                }\n                // Take the difference between these frames.\n                var frameLength = frames1.length;\n                calcSub = [];\n                for (u = 0; u < frameLength; u++) {\n                    calcSub[u] = frames1[u] - frames2[u];\n                }\n                // Sum the differences.\n                var summation = 0;\n                for (u = 0; u < frameLength; u++) {\n                    summation += Math.abs(calcSub[u]);\n                }\n                amd[i] = summation;\n            }\n        }\n        for (j = minPeriod; j < maxPeriod; j++) {\n            if (amd[j] < minval)\n                minval = amd[j];\n            if (amd[j] > maxval)\n                maxval = amd[j];\n        }\n        var cutoff = Math.round(sensitivity * (maxval - minval) + minval);\n        for (j = minPeriod; j <= maxPeriod && amd[j] > cutoff; j++)\n            ;\n        var searchLength = minPeriod / 2;\n        minval = amd[j];\n        var minpos = j;\n        for (i = j - 1; i < j + searchLength && i <= maxPeriod; i++) {\n            if (amd[i] < minval) {\n                minval = amd[i];\n                minpos = i;\n            }\n        }\n        if (Math.round(amd[minpos] * ratio) < maxval) {\n            return sampleRate / minpos;\n        }\n        else {\n            return null;\n        }\n    };\n}\nexports.AMDF = AMDF;\n\n\n//# sourceURL=webpack:///./node_modules/pitchfinder/lib/detectors/amdf.js?");

/***/ }),

/***/ "./node_modules/pitchfinder/lib/detectors/dynamic_wavelet.js":
/*!*******************************************************************!*\
  !*** ./node_modules/pitchfinder/lib/detectors/dynamic_wavelet.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar MAX_FLWT_LEVELS = 6;\nvar MAX_F = 3000;\nvar DIFFERENCE_LEVELS_N = 3;\nvar MAXIMA_THRESHOLD_RATIO = 0.75;\nvar DEFAULT_DYNAMIC_WAVELET_CONFIG = {\n    sampleRate: 44100,\n};\nfunction DynamicWavelet(params) {\n    if (params === void 0) { params = {}; }\n    var config = __assign(__assign({}, DEFAULT_DYNAMIC_WAVELET_CONFIG), params);\n    var sampleRate = config.sampleRate;\n    return function DynamicWaveletDetector(float32AudioBuffer) {\n        var mins = [];\n        var maxs = [];\n        var bufferLength = float32AudioBuffer.length;\n        var freq = null;\n        var theDC = 0;\n        var minValue = 0;\n        var maxValue = 0;\n        // Compute max amplitude, amplitude threshold, and the DC.\n        for (var i = 0; i < bufferLength; i++) {\n            var sample = float32AudioBuffer[i];\n            theDC = theDC + sample;\n            maxValue = Math.max(maxValue, sample);\n            minValue = Math.min(minValue, sample);\n        }\n        theDC /= bufferLength;\n        minValue -= theDC;\n        maxValue -= theDC;\n        var amplitudeMax = maxValue > -1 * minValue ? maxValue : -1 * minValue;\n        var amplitudeThreshold = amplitudeMax * MAXIMA_THRESHOLD_RATIO;\n        // levels, start without downsampling...\n        var curLevel = 0;\n        var curModeDistance = -1;\n        var curSamNb = float32AudioBuffer.length;\n        var delta, nbMaxs, nbMins;\n        // Search:\n        while (true) {\n            delta = ~~(sampleRate / (Math.pow(2, curLevel) * MAX_F));\n            if (curSamNb < 2)\n                break;\n            var dv = void 0;\n            var previousDV = -1000;\n            var lastMinIndex = -1000000;\n            var lastMaxIndex = -1000000;\n            var findMax = false;\n            var findMin = false;\n            nbMins = 0;\n            nbMaxs = 0;\n            for (var i = 2; i < curSamNb; i++) {\n                var si = float32AudioBuffer[i] - theDC;\n                var si1 = float32AudioBuffer[i - 1] - theDC;\n                if (si1 <= 0 && si > 0)\n                    findMax = true;\n                if (si1 >= 0 && si < 0)\n                    findMin = true;\n                // min or max ?\n                dv = si - si1;\n                if (previousDV > -1000) {\n                    if (findMin && previousDV < 0 && dv >= 0) {\n                        // minimum\n                        if (Math.abs(si) >= amplitudeThreshold) {\n                            if (i > lastMinIndex + delta) {\n                                mins[nbMins++] = i;\n                                lastMinIndex = i;\n                                findMin = false;\n                            }\n                        }\n                    }\n                    if (findMax && previousDV > 0 && dv <= 0) {\n                        // maximum\n                        if (Math.abs(si) >= amplitudeThreshold) {\n                            if (i > lastMaxIndex + delta) {\n                                maxs[nbMaxs++] = i;\n                                lastMaxIndex = i;\n                                findMax = false;\n                            }\n                        }\n                    }\n                }\n                previousDV = dv;\n            }\n            if (nbMins === 0 && nbMaxs === 0) {\n                // No best distance found!\n                break;\n            }\n            var d = void 0;\n            var distances = [];\n            for (var i = 0; i < curSamNb; i++) {\n                distances[i] = 0;\n            }\n            for (var i = 0; i < nbMins; i++) {\n                for (var j = 1; j < DIFFERENCE_LEVELS_N; j++) {\n                    if (i + j < nbMins) {\n                        d = Math.abs(mins[i] - mins[i + j]);\n                        distances[d] += 1;\n                    }\n                }\n            }\n            var bestDistance = -1;\n            var bestValue = -1;\n            for (var i = 0; i < curSamNb; i++) {\n                var summed = 0;\n                for (var j = -1 * delta; j <= delta; j++) {\n                    if (i + j >= 0 && i + j < curSamNb) {\n                        summed += distances[i + j];\n                    }\n                }\n                if (summed === bestValue) {\n                    if (i === 2 * bestDistance) {\n                        bestDistance = i;\n                    }\n                }\n                else if (summed > bestValue) {\n                    bestValue = summed;\n                    bestDistance = i;\n                }\n            }\n            // averaging\n            var distAvg = 0;\n            var nbDists = 0;\n            for (var j = -delta; j <= delta; j++) {\n                if (bestDistance + j >= 0 && bestDistance + j < bufferLength) {\n                    var nbDist = distances[bestDistance + j];\n                    if (nbDist > 0) {\n                        nbDists += nbDist;\n                        distAvg += (bestDistance + j) * nbDist;\n                    }\n                }\n            }\n            // This is our mode distance.\n            distAvg /= nbDists;\n            // Continue the levels?\n            if (curModeDistance > -1) {\n                if (Math.abs(distAvg * 2 - curModeDistance) <= 2 * delta) {\n                    // two consecutive similar mode distances : ok !\n                    freq = sampleRate / (Math.pow(2, curLevel - 1) * curModeDistance);\n                    break;\n                }\n            }\n            // not similar, continue next level;\n            curModeDistance = distAvg;\n            curLevel++;\n            if (curLevel >= MAX_FLWT_LEVELS || curSamNb < 2) {\n                break;\n            }\n            //do not modify original audio buffer, make a copy buffer, if\n            //downsampling is needed (only once).\n            var newFloat32AudioBuffer = float32AudioBuffer.subarray(0);\n            if (curSamNb === distances.length) {\n                newFloat32AudioBuffer = new Float32Array(curSamNb / 2);\n            }\n            for (var i = 0; i < curSamNb / 2; i++) {\n                newFloat32AudioBuffer[i] =\n                    (float32AudioBuffer[2 * i] + float32AudioBuffer[2 * i + 1]) / 2;\n            }\n            float32AudioBuffer = newFloat32AudioBuffer;\n            curSamNb /= 2;\n        }\n        return freq;\n    };\n}\nexports.DynamicWavelet = DynamicWavelet;\n\n\n//# sourceURL=webpack:///./node_modules/pitchfinder/lib/detectors/dynamic_wavelet.js?");

/***/ }),

/***/ "./node_modules/pitchfinder/lib/detectors/macleod.js":
/*!***********************************************************!*\
  !*** ./node_modules/pitchfinder/lib/detectors/macleod.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar DEFAULT_MACLEOD_PARAMS = {\n    bufferSize: 1024,\n    cutoff: 0.97,\n    sampleRate: 44100,\n};\nfunction Macleod(params) {\n    if (params === void 0) { params = {}; }\n    var config = __assign(__assign({}, DEFAULT_MACLEOD_PARAMS), params);\n    var bufferSize = config.bufferSize, cutoff = config.cutoff, sampleRate = config.sampleRate;\n    /**\n     * For performance reasons, peaks below this cutoff are not even considered.\n     */\n    var SMALL_CUTOFF = 0.5;\n    /**\n     * Pitch annotations below this threshold are considered invalid, they are\n     * ignored.\n     */\n    var LOWER_PITCH_CUTOFF = 80;\n    /**\n     * Contains a normalized square difference function value for each delay\n     * (tau).\n     */\n    var nsdf = new Float32Array(bufferSize);\n    /**\n     * Contains a sum of squares of the Buffer, for improving performance\n     * (avoids redoing math in the normalized square difference function)\n     */\n    var squaredBufferSum = new Float32Array(bufferSize);\n    /**\n     * The x and y coordinate of the top of the curve (nsdf).\n     */\n    var turningPointX;\n    var turningPointY;\n    /**\n     * A list with minimum and maximum values of the nsdf curve.\n     */\n    var maxPositions = [];\n    /**\n     * A list of estimates of the period of the signal (in samples).\n     */\n    var periodEstimates = [];\n    /**\n     * A list of estimates of the amplitudes corresponding with the period\n     * estimates.\n     */\n    var ampEstimates = [];\n    /**\n     * Implements the normalized square difference function. See section 4 (and\n     * the explanation before) in the MPM article. This calculation can be\n     * optimized by using an FFT. The results should remain the same.\n     */\n    function normalizedSquareDifference(float32AudioBuffer) {\n        var acf;\n        var divisorM;\n        squaredBufferSum[0] = float32AudioBuffer[0] * float32AudioBuffer[0];\n        for (var i = 1; i < float32AudioBuffer.length; i += 1) {\n            squaredBufferSum[i] =\n                float32AudioBuffer[i] * float32AudioBuffer[i] + squaredBufferSum[i - 1];\n        }\n        for (var tau = 0; tau < float32AudioBuffer.length; tau++) {\n            acf = 0;\n            divisorM =\n                squaredBufferSum[float32AudioBuffer.length - 1 - tau] +\n                    squaredBufferSum[float32AudioBuffer.length - 1] -\n                    squaredBufferSum[tau];\n            for (var i = 0; i < float32AudioBuffer.length - tau; i++) {\n                acf += float32AudioBuffer[i] * float32AudioBuffer[i + tau];\n            }\n            nsdf[tau] = (2 * acf) / divisorM;\n        }\n    }\n    /**\n     * Finds the x value corresponding with the peak of a parabola.\n     * Interpolates between three consecutive points centered on tau.\n     */\n    function parabolicInterpolation(tau) {\n        var nsdfa = nsdf[tau - 1], nsdfb = nsdf[tau], nsdfc = nsdf[tau + 1], bValue = tau, bottom = nsdfc + nsdfa - 2 * nsdfb;\n        if (bottom === 0) {\n            turningPointX = bValue;\n            turningPointY = nsdfb;\n        }\n        else {\n            var delta = nsdfa - nsdfc;\n            turningPointX = bValue + delta / (2 * bottom);\n            turningPointY = nsdfb - (delta * delta) / (8 * bottom);\n        }\n    }\n    // Finds the highest value between each pair of positive zero crossings.\n    function peakPicking() {\n        var pos = 0;\n        var curMaxPos = 0;\n        // find the first negative zero crossing.\n        while (pos < (nsdf.length - 1) / 3 && nsdf[pos] > 0) {\n            pos++;\n        }\n        // loop over all the values below zero.\n        while (pos < nsdf.length - 1 && nsdf[pos] <= 0) {\n            pos++;\n        }\n        // can happen if output[0] is NAN\n        if (pos == 0) {\n            pos = 1;\n        }\n        while (pos < nsdf.length - 1) {\n            if (nsdf[pos] > nsdf[pos - 1] && nsdf[pos] >= nsdf[pos + 1]) {\n                if (curMaxPos == 0) {\n                    // the first max (between zero crossings)\n                    curMaxPos = pos;\n                }\n                else if (nsdf[pos] > nsdf[curMaxPos]) {\n                    // a higher max (between the zero crossings)\n                    curMaxPos = pos;\n                }\n            }\n            pos++;\n            // a negative zero crossing\n            if (pos < nsdf.length - 1 && nsdf[pos] <= 0) {\n                // if there was a maximum add it to the list of maxima\n                if (curMaxPos > 0) {\n                    maxPositions.push(curMaxPos);\n                    curMaxPos = 0; // clear the maximum position, so we start\n                    // looking for a new ones\n                }\n                while (pos < nsdf.length - 1 && nsdf[pos] <= 0) {\n                    pos++; // loop over all the values below zero\n                }\n            }\n        }\n        if (curMaxPos > 0) {\n            maxPositions.push(curMaxPos);\n        }\n    }\n    return function Macleod(float32AudioBuffer) {\n        // 0. Clear old results.\n        var pitch;\n        maxPositions = [];\n        periodEstimates = [];\n        ampEstimates = [];\n        // 1. Calculute the normalized square difference for each Tau value.\n        normalizedSquareDifference(float32AudioBuffer);\n        // 2. Peak picking time: time to pick some peaks.\n        peakPicking();\n        var highestAmplitude = -Infinity;\n        for (var i = 0; i < maxPositions.length; i++) {\n            var tau = maxPositions[i];\n            // make sure every annotation has a probability attached\n            highestAmplitude = Math.max(highestAmplitude, nsdf[tau]);\n            if (nsdf[tau] > SMALL_CUTOFF) {\n                // calculates turningPointX and Y\n                parabolicInterpolation(tau);\n                // store the turning points\n                ampEstimates.push(turningPointY);\n                periodEstimates.push(turningPointX);\n                // remember the highest amplitude\n                highestAmplitude = Math.max(highestAmplitude, turningPointY);\n            }\n        }\n        if (periodEstimates.length) {\n            // use the overall maximum to calculate a cutoff.\n            // The cutoff value is based on the highest value and a relative\n            // threshold.\n            var actualCutoff = cutoff * highestAmplitude;\n            var periodIndex = 0;\n            for (var i = 0; i < ampEstimates.length; i++) {\n                if (ampEstimates[i] >= actualCutoff) {\n                    periodIndex = i;\n                    break;\n                }\n            }\n            var period = periodEstimates[periodIndex], pitchEstimate = sampleRate / period;\n            if (pitchEstimate > LOWER_PITCH_CUTOFF) {\n                pitch = pitchEstimate;\n            }\n            else {\n                pitch = -1;\n            }\n        }\n        else {\n            // no pitch detected.\n            pitch = -1;\n        }\n        return {\n            probability: highestAmplitude,\n            freq: pitch,\n        };\n    };\n}\nexports.Macleod = Macleod;\n\n\n//# sourceURL=webpack:///./node_modules/pitchfinder/lib/detectors/macleod.js?");

/***/ }),

/***/ "./node_modules/pitchfinder/lib/detectors/yin.js":
/*!*******************************************************!*\
  !*** ./node_modules/pitchfinder/lib/detectors/yin.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\n/*\n  Copyright (C) 2003-2009 Paul Brossier <piem@aubio.org>\n  This file is part of aubio.\n  aubio is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n  aubio is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n  You should have received a copy of the GNU General Public License\n  along with aubio.  If not, see <http://www.gnu.org/licenses/>.\n*/\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar DEFAULT_YIN_PARAMS = {\n    threshold: 0.1,\n    sampleRate: 44100,\n    probabilityThreshold: 0.1,\n};\nfunction YIN(params) {\n    if (params === void 0) { params = {}; }\n    var config = __assign(__assign({}, DEFAULT_YIN_PARAMS), params);\n    var threshold = config.threshold, sampleRate = config.sampleRate, probabilityThreshold = config.probabilityThreshold;\n    return function YINDetector(float32AudioBuffer) {\n        // Set buffer size to the highest power of two below the provided buffer's length.\n        var bufferSize;\n        for (bufferSize = 1; bufferSize < float32AudioBuffer.length; bufferSize *= 2)\n            ;\n        bufferSize /= 2;\n        // Set up the yinBuffer as described in step one of the YIN paper.\n        var yinBufferLength = bufferSize / 2;\n        var yinBuffer = new Float32Array(yinBufferLength);\n        var probability = 0, tau;\n        // Compute the difference function as described in step 2 of the YIN paper.\n        for (var t = 0; t < yinBufferLength; t++) {\n            yinBuffer[t] = 0;\n        }\n        for (var t = 1; t < yinBufferLength; t++) {\n            for (var i = 0; i < yinBufferLength; i++) {\n                var delta = float32AudioBuffer[i] - float32AudioBuffer[i + t];\n                yinBuffer[t] += delta * delta;\n            }\n        }\n        // Compute the cumulative mean normalized difference as described in step 3 of the paper.\n        yinBuffer[0] = 1;\n        yinBuffer[1] = 1;\n        var runningSum = 0;\n        for (var t = 1; t < yinBufferLength; t++) {\n            runningSum += yinBuffer[t];\n            yinBuffer[t] *= t / runningSum;\n        }\n        // Compute the absolute threshold as described in step 4 of the paper.\n        // Since the first two positions in the array are 1,\n        // we can start at the third position.\n        for (tau = 2; tau < yinBufferLength; tau++) {\n            if (yinBuffer[tau] < threshold) {\n                while (tau + 1 < yinBufferLength && yinBuffer[tau + 1] < yinBuffer[tau]) {\n                    tau++;\n                }\n                // found tau, exit loop and return\n                // store the probability\n                // From the YIN paper: The threshold determines the list of\n                // candidates admitted to the set, and can be interpreted as the\n                // proportion of aperiodic power tolerated\n                // within a periodic signal.\n                //\n                // Since we want the periodicity and and not aperiodicity:\n                // periodicity = 1 - aperiodicity\n                probability = 1 - yinBuffer[tau];\n                break;\n            }\n        }\n        // if no pitch found, return null.\n        if (tau === yinBufferLength || yinBuffer[tau] >= threshold) {\n            return null;\n        }\n        // If probability too low, return -1.\n        if (probability < probabilityThreshold) {\n            return null;\n        }\n        /**\n         * Implements step 5 of the AUBIO_YIN paper. It refines the estimated tau\n         * value using parabolic interpolation. This is needed to detect higher\n         * frequencies more precisely. See http://fizyka.umk.pl/nrbook/c10-2.pdf and\n         * for more background\n         * http://fedc.wiwi.hu-berlin.de/xplore/tutorials/xegbohtmlnode62.html\n         */\n        var betterTau, x0, x2;\n        if (tau < 1) {\n            x0 = tau;\n        }\n        else {\n            x0 = tau - 1;\n        }\n        if (tau + 1 < yinBufferLength) {\n            x2 = tau + 1;\n        }\n        else {\n            x2 = tau;\n        }\n        if (x0 === tau) {\n            if (yinBuffer[tau] <= yinBuffer[x2]) {\n                betterTau = tau;\n            }\n            else {\n                betterTau = x2;\n            }\n        }\n        else if (x2 === tau) {\n            if (yinBuffer[tau] <= yinBuffer[x0]) {\n                betterTau = tau;\n            }\n            else {\n                betterTau = x0;\n            }\n        }\n        else {\n            var s0 = yinBuffer[x0];\n            var s1 = yinBuffer[tau];\n            var s2 = yinBuffer[x2];\n            // fixed AUBIO implementation, thanks to Karl Helgason:\n            // (2.0f * s1 - s2 - s0) was incorrectly multiplied with -1\n            betterTau = tau + (s2 - s0) / (2 * (2 * s1 - s2 - s0));\n        }\n        return sampleRate / betterTau;\n    };\n}\nexports.YIN = YIN;\n\n\n//# sourceURL=webpack:///./node_modules/pitchfinder/lib/detectors/yin.js?");

/***/ }),

/***/ "./node_modules/pitchfinder/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/pitchfinder/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar yin_1 = __webpack_require__(/*! ./detectors/yin */ \"./node_modules/pitchfinder/lib/detectors/yin.js\");\nexports.YIN = yin_1.YIN;\nvar amdf_1 = __webpack_require__(/*! ./detectors/amdf */ \"./node_modules/pitchfinder/lib/detectors/amdf.js\");\nexports.AMDF = amdf_1.AMDF;\nvar acf2plus_1 = __webpack_require__(/*! ./detectors/acf2plus */ \"./node_modules/pitchfinder/lib/detectors/acf2plus.js\");\nexports.ACF2PLUS = acf2plus_1.ACF2PLUS;\nvar dynamic_wavelet_1 = __webpack_require__(/*! ./detectors/dynamic_wavelet */ \"./node_modules/pitchfinder/lib/detectors/dynamic_wavelet.js\");\nexports.DynamicWavelet = dynamic_wavelet_1.DynamicWavelet;\nvar macleod_1 = __webpack_require__(/*! ./detectors/macleod */ \"./node_modules/pitchfinder/lib/detectors/macleod.js\");\nexports.Macleod = macleod_1.Macleod;\nvar frequencies_1 = __webpack_require__(/*! ./tools/frequencies */ \"./node_modules/pitchfinder/lib/tools/frequencies.js\");\nexports.default = {\n    YIN: yin_1.YIN,\n    AMDF: amdf_1.AMDF,\n    ACF2PLUS: acf2plus_1.ACF2PLUS,\n    DynamicWavelet: dynamic_wavelet_1.DynamicWavelet,\n    Macleod: macleod_1.Macleod,\n    frequencies: frequencies_1.frequencies,\n};\n\n\n//# sourceURL=webpack:///./node_modules/pitchfinder/lib/index.js?");

/***/ }),

/***/ "./node_modules/pitchfinder/lib/tools/frequencies.js":
/*!***********************************************************!*\
  !*** ./node_modules/pitchfinder/lib/tools/frequencies.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_FREQUENCIES_PARAMS = {\n    tempo: 120,\n    quantization: 4,\n    sampleRate: 44100,\n};\nfunction pitchConsensus(detectors, chunk) {\n    var pitches = detectors\n        .map(function (fn) { return fn(chunk); })\n        .filter(function (value) { return value !== null; })\n        .sort(function (a, b) { return a - b; });\n    // In the case of one pitch, return it.\n    if (pitches.length === 1) {\n        return pitches[0];\n        // In the case of two pitches, return the geometric mean if they\n        // are close to each other, and the lower pitch otherwise.\n    }\n    else if (pitches.length === 2) {\n        var first = pitches[0], second = pitches[1];\n        return first * 2 > second ? Math.sqrt(first * second) : first;\n        // In the case of three or more pitches, filter away the extremes\n        // if they are very extreme, then take the geometric mean.\n    }\n    else {\n        var first = pitches[0];\n        var second = pitches[1];\n        var secondToLast = pitches[pitches.length - 2];\n        var last = pitches[pitches.length - 1];\n        var filtered1 = first * 2 > second ? pitches : pitches.slice(1);\n        var filtered2 = secondToLast * 2 > last ? filtered1 : filtered1.slice(0, -1);\n        return Math.pow(filtered2.reduce(function (t, p) { return t * p; }, 1), 1 / filtered2.length);\n    }\n}\nfunction frequencies(detector, float32AudioBuffer, options) {\n    if (options === void 0) { options = {}; }\n    var config = __assign(__assign({}, exports.DEFAULT_FREQUENCIES_PARAMS), options);\n    var tempo = config.tempo, quantization = config.quantization, sampleRate = config.sampleRate;\n    var bufferLength = float32AudioBuffer.length;\n    var chunkSize = Math.round((sampleRate * 60) / (quantization * tempo));\n    var getPitch;\n    if (Array.isArray(detector)) {\n        getPitch = pitchConsensus.bind(null, detector);\n    }\n    else {\n        getPitch = detector;\n    }\n    var pitches = [];\n    for (var i = 0, max = bufferLength - chunkSize; i <= max; i += chunkSize) {\n        var chunk = float32AudioBuffer.slice(i, i + chunkSize);\n        var pitch = getPitch(chunk);\n        pitches.push(pitch);\n    }\n    return pitches;\n}\nexports.frequencies = frequencies;\n\n\n//# sourceURL=webpack:///./node_modules/pitchfinder/lib/tools/frequencies.js?");

/***/ }),

/***/ "./src/js/index.js":
/*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tuner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tuner */ \"./src/js/tuner.js\");\n\n\nconst BASE_URL = 'http://localhost:3000/'\n\nconst noteH1 = () => document.getElementById('note')\nconst freqH2 = () => document.getElementById('freq')\nconst tuningNameH3 = () => document.getElementById('tuning-name')\nconst tuningNotesH4 = () => document.getElementById('tuning-notes')\nconst instrumentNameH1 = () => document.getElementById('instrument-name')\nconst tuningForm = () => document.getElementById('tuning-form')\nconst tuningFormSelect = () => document.getElementById('tuning-form-select')\nconst tuningFormSubmit = () => document.getElementById('tuning-form-submit')\n\nlet matchNotesInterval\nlet tuner\n\ndocument.addEventListener('DOMContentLoaded', (event) => {\n  getInstrument(1)\n    .then((instrument) => displayInstrument(instrument))\n    .then((instrument) => {\n      showTuningForm()\n      populateTuningForm(instrument)\n    })\n})\n\nconst fetchData = (route) => {\n  return fetch(BASE_URL + route, {\n    headers: { Accept: 'application/json' }\n  })\n    .then((response) => response.json())\n    .then((json) => json)\n    .catch((error) => console.error(error))\n}\n\nconst getTuning = (id) => fetchData(`tunings/${id}`)\nconst getTunings = () => fetchData('tunings')\nconst getInstrument = (id) => fetchData(`instruments/${id}`)\nconst getInstruments = () => fetchData('instruments')\n\nconst showTuningForm = () => {\n  const tuningForm = document.createElement('form')\n  const tuningFormSelect = document.createElement('select')\n  const tuningFormSubmit = document.createElement('input')\n\n  tuningForm.id = 'tuning-form'\n  tuningFormSelect.id = 'tuning-form-select'\n  tuningFormSubmit.id = 'tuning-form-submit'\n  tuningFormSubmit.type = 'submit'\n  tuningFormSelect.addEventListener('change', updateTuning)\n  tuningForm.addEventListener('submit', updateTuning)\n  tuningForm.appendChild(tuningFormSelect)\n  tuningForm.appendChild(tuningFormSubmit)\n  document.body.appendChild(tuningForm)\n}\n\nconst populateTuningForm = (instrument) => {\n  const tunings = instrument.included\n  for (const tuning of tunings) {\n    const option = document.createElement('option')\n    const string = `${tuning.attributes.name}: ${tuning.attributes.notes.join(\n      ', '\n    )}`\n    option.value = string\n    option.text = string\n    tuningFormSelect().appendChild(option)\n  }\n}\n\nconst displayTuning = (tuning, name = '') => {\n  const h3 = tuningNameH3() || document.createElement('h3')\n  const h4 = tuningNotesH4() || document.createElement('h4')\n  h3.id = 'tuning-name'\n  h4.id = 'tuning-notes'\n  let notes = []\n  if (typeof tuning !== 'undefined') {\n    if (typeof tuning.data !== 'undefined') {\n      notes = tuning.data.attributes.notes\n      h3.textContent = tuning.data.attributes.name\n    } else if (typeof tuning.attributes !== 'undefined') {\n      notes = tuning.attributes.notes\n      h3.textContent = tuning.attributes.name\n    } else {\n      notes = tuning.split(', ')\n      h3.textContent = name\n    }\n  }\n  h4.textContent = notes.join(' ')\n  if (!tuningNameH3()) {\n    document.body.appendChild(h3)\n  }\n  if (!tuningNotesH4()) {\n    document.body.appendChild(h4)\n  }\n  return notes\n}\n\nconst displayTunings = (tunings) => {\n  if (typeof tunings !== 'undefined') {\n    for (const tuning of tunings) {\n      displayTuning(tuning)\n    }\n    return tunings\n  }\n  return []\n}\n\nconst displayInstrument = (instrument) => {\n  if (typeof instrument !== 'undefined') {\n    const h1 = document.createElement('h1')\n    const tunings = instrument.included\n    h1.id = 'instrument-name'\n    h1.textContent = instrument.data.attributes.name\n    document.body.append(h1)\n    //displayTunings(tunings)\n  }\n  return instrument\n}\n\nconst displayInstruments = (instruments) => {\n  for (const instrument of instruments) {\n    displayInstrument(instrument)\n  }\n}\n\nconst createTuner = () => {\n  return new Promise((resolve, reject) => {\n    try {\n      tuner = tuner instanceof _tuner__WEBPACK_IMPORTED_MODULE_0__.default ? tuner : new _tuner__WEBPACK_IMPORTED_MODULE_0__.default()\n      resolve(tuner)\n    } catch (e) {\n      reject(`Error while creating tuner: ${e}`)\n    }\n  })\n}\n\nconst startAndDisplayTuner = (stoppedTuner, interval) => {\n  return stoppedTuner\n    .startTuner()\n    .then((startedTuner) => {\n      const h1 = document.createElement('h1')\n      const h2 = document.createElement('h2')\n      h1.id = 'note'\n      h2.id = 'freq'\n      document.body.append(h1, h2)\n      startedTuner.displayAtInterval(interval)\n      return startedTuner\n    })\n    .catch((error) => {\n      console.error(error)\n    })\n}\n\nconst highlightMatchingNotes = (startedTuner, notes, interval) => {\n  try {\n    clearInterval(matchNotesInterval)\n  } catch (e) {\n    console.error(e)\n  }\n  matchNotesInterval = setInterval(() => {\n    if (startedTuner.matchNotes(notes)) {\n      noteH1().style.color = 'green'\n    } else {\n      noteH1().style.color = 'black'\n    }\n  }, interval)\n  return tuner\n}\n\nconst updateTuning = (event) => {\n  event.preventDefault()\n  const tuningPair =\n    typeof event.target.value === 'undefined'\n      ? event.target.children[0].value.split(': ')\n      : event.target.value.split(': ')\n  const tuningName = tuningPair[0]\n  const tuning = tuningPair[1]\n  displayTuning(tuning, tuningName)\n  tuningNameH3().textContent = tuningName\n  tuningNotesH4().textContent = tuning\n  createTuner()\n    .then((stoppedTuner) => startAndDisplayTuner(stoppedTuner, 100))\n    .then((startedTuner) =>\n      highlightMatchingNotes(startedTuner, tuning.split(', '), 100)\n    )\n    .then((tuner) => tuner.drawGuage())\n}\n\n\n//# sourceURL=webpack:///./src/js/index.js?");

/***/ }),

/***/ "./src/js/tuner.js":
/*!*************************!*\
  !*** ./src/js/tuner.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var pitchfinder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pitchfinder */ \"./node_modules/pitchfinder/lib/index.js\");\n\n\nclass Tuner {\n  constructor() {\n    this._pitchArray = []\n    this._displayInterval = null\n    this.currentPitch = Tuner.c0\n    this.currentNote = 'c0'\n    this.started = false\n  }\n\n  static a4 = 440\n  static c0 = Tuner.a4 * 2 ** -4.75\n  static notes = [\n    'c',\n    'c#',\n    'd',\n    'd#',\n    'e',\n    'f',\n    'f#',\n    'g',\n    'g#',\n    'a',\n    'a#',\n    'b'\n  ]\n\n  static noteScaleArray = Tuner.notesWithOctave(Tuner.notes)\n  static pitchMap = Tuner.mapPitches(Tuner.noteScaleArray)\n\n  static convertPitch(pitch) {\n    const h = Math.round(12 * Math.log2(pitch / Tuner.c0))\n    const octave = Math.floor(h / 12)\n    const index = h % 12\n    return Tuner.notes[index] + octave.toString()\n  }\n\n  static convertNote(note) {\n    return this.pitchMap[note]\n  }\n\n  static notesWithOctave(notes) {\n    const array = []\n    for (let i = 0; i <= 8; i++) {\n      for (const note of notes) {\n        array.push(note + i.toString())\n      }\n    }\n    return array\n  }\n\n  static mapPitches(noteScaleArray) {\n    const map = {}\n    for (const note of noteScaleArray) {\n      for (let pitch = 16.35; pitch <= 7902.13; pitch += 0.01) {\n        if (Tuner.convertPitch(pitch) === note) {\n          map[note] = pitch\n          break\n        }\n      }\n    }\n    return map\n  }\n\n  static display(note, freq) {\n    const h1 = () => document.getElementById('note')\n    const h2 = () => document.getElementById('freq')\n    h1().textContent = note.toUpperCase()\n    h2().textContent = freq\n  }\n\n  displayAtInterval(interval) {\n    let sum = 0\n    try {\n      clearInterval(this._displayInterval)\n    } catch (e) {\n      console.error(e)\n    }\n    this._displayInterval = setInterval(() => {\n      if (this._pitchArray.length > 0) {\n        for (const pitch of this._pitchArray) {\n          sum += pitch\n        }\n        if (!(isNaN(sum) || typeof sum === 'undefined') && sum >= Tuner.c0) {\n          const avg = sum / this._pitchArray.length\n          this.currentNote = Tuner.convertPitch(avg)\n          Tuner.display(this.currentNote, avg)\n        }\n        this._pitchArray = []\n        sum = 0\n      }\n    }, interval)\n  }\n\n  startTuner() {\n    return new Promise((resolve, reject) => {\n      try {\n        if (this.started === false) {\n          navigator.mediaDevices\n            .getUserMedia({ audio: true, video: false })\n            .then((stream) => {\n              const audioContext = new AudioContext()\n              const source = audioContext.createMediaStreamSource(stream)\n              const processor = audioContext.createScriptProcessor(2048, 1, 1)\n              processor.onaudioprocess = (event) => {\n                const micData = event.inputBuffer.getChannelData(0)\n                const detectPitch = pitchfinder__WEBPACK_IMPORTED_MODULE_0__.default.ACF2PLUS({\n                  sampleRate: audioContext.sampleRate\n                })\n                this.currentPitch = detectPitch(micData)\n                if (\n                  this.currentPitch < 16000 &&\n                  this.currentPitch >= Tuner.c0 &&\n                  !(\n                    isNaN(this.currentPitch) ||\n                    typeof this.currentPitch === 'undefined'\n                  )\n                ) {\n                  this._pitchArray.push(this.currentPitch)\n                }\n              }\n              source.connect(processor)\n              processor.connect(audioContext.destination)\n            })\n            .then(() => {\n              this.started = true\n            })\n        }\n        resolve(this)\n      } catch (e) {\n        this.started = false\n        reject(`Error during tuner setup: ${e}`)\n      }\n    })\n  }\n\n  matchNotes(notesArray) {\n    for (const note of notesArray) {\n      if (note.toLowerCase() === this.currentNote) {\n        return true\n      }\n    }\n    return false\n  }\n\n  drawGuage() {\n    const guage = document.createElement('div')\n    const needle = document.createElement('div')\n\n    guage.style.height = '50px'\n    guage.style.width = '1000px'\n    guage.style.position = 'fixed'\n    guage.style.bottom = '50%'\n    guage.style.left = '100px'\n    guage.style.backgroundColor = 'rgb(0, 100, 200)'\n\n    needle.style.height = '50px'\n    needle.style.width = '10px'\n    needle.style.position = 'fixed'\n    needle.style.bottom = '50%'\n    needle.style.left = '100px'\n    needle.style.backgroundColor = 'rgb(0, 200, 100)'\n\n    guage.appendChild(needle)\n    document.body.appendChild(guage)\n\n    setInterval(() => {\n      let min = Tuner.convertNote(this.currentNote)\n      let mid = this.currentPitch\n      let max =\n        Tuner.pitchMap[\n          Tuner.noteScaleArray[\n            Tuner.noteScaleArray.indexOf(this.currentNote) + 1\n          ]\n        ]\n      mid = mid < min ? min : mid\n      mid = mid > max ? max : mid\n      let range = max - min\n      range = range < 0 ? 0 : range\n      let position = mid - min\n      position = position < 0 ? 0 : position\n      let percentage = range <= 0 ? 100 : position / range\n      let final = percentage * 1000 + 100\n      final = final > 1100 ? 1100 : final\n      needle.style.left = `${final}px`\n    }, 50)\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tuner);\n\n\n//# sourceURL=webpack:///./src/js/tuner.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/index.js");
/******/ 	
/******/ })()
;